/*
 * @Author: Justin
 * @Date: 2023-01-30 13:08:19
 * @LastEditors: Justin
 * @LastEditTime: 2023-01-30 17:28:19
 * @FilePath: \PopCorn-soft\project\code\VOFA.c
 * @Description:  主要是vofa的firewater的通信协议
 */
#if 1
#include "VOFA.h"

unsigned char tail[4] = {0x00, 0x00, 0x80, 0x7f};

uart_index_enum Chal;
uint8 uart_get_data[64]; // 串口接收数据缓冲区
uint8 fifo_get_data[64]; // fifo 输出读出缓冲区

uint8 get_data = 0;         // 接收数据变量
uint32 fifo_data_count = 0; // fifo 数据个数

fifo_struct uart_data_fifo;

void VOFAInit()
{

    //    bluetooth_ch9141_init();
    Chal = UART_3;
}
vuint32 Recdata = 0;
uint8 dat = 0;
// void uart_rx_interrupt_handler (void)
//{
//     uart_query_byte(UART_0, &dat);
//     fifo_write_buffer(&uart_data_fifo, &dat, 1);
// }
// void GetRecData(){
//     fifo_data_count = fifo_used(&uart_data_fifo);                           // 查看 fifo 是否有数据
//     if(fifo_data_count != 0)                                                // 读取到数据了
//     {
//         fifo_read_buffer(&uart_data_fifo, fifo_get_data, &fifo_data_count, FIFO_READ_AND_CLEAN);    // 将 fifo 中数据读出并清空 fifo 挂载的缓冲
//         Recdata = myfunc_str_to_int(&fifo_get_data,fifo_data_count);
//         Print("%d\n",Recdata);
//     }
// }
//  计算m^n
unsigned long m_pow_n(unsigned long m, unsigned long n)
{
    unsigned long i = 0, ret = 1;
    if (n < 0)
        return 0;
    for (i = 0; i < n; i++)
    {
        ret *= m;
    }
    return ret;
}

// 返回值为打印字符的个数
// 支持%d，%o, %x，%s，%c，%f（只打印6位数字）
void justf()
{
    for (int i = 0; i < 4; i++)
    {
        my_send_char(tail[i]);
    }
}

int Print(const char *str, ...)
{
    if (str == NULL)
        return -1;

    unsigned int ret_num = 0;    // 返回打印字符的个数
    char *pStr = (char *)str;    // 指向str
    int ArgIntVal = 0;           // 接收整型
    unsigned long ArgHexVal = 0; // 接十六进制
    char *ArgStrVal = NULL;      // 接收字符型
    double ArgFloVal = 0.0;      // 接受浮点型
    unsigned long val_seg = 0;   // 数据切分
    unsigned long val_temp = 0;  // 临时保存数据
    int cnt = 0;                 // 数据长度计数
                                 //    int i = 0;

    va_list pArgs;        // 定义va_list类型指针，用于存储参数的地址
    va_start(pArgs, str); // 初始化pArgs
    while (*pStr != '\0')
    {
        switch (*pStr)
        {
        case ' ':
            my_send_char(*pStr);
            ret_num++;
            break;
        case '\t':
            my_send_char(*pStr);
            ret_num += 4;
            break;
        case '\r':
            my_send_char(*pStr);
            ret_num++;
            break;
        case '\n':
            my_send_char(*pStr);
            ret_num++;
            break;
        case '%':
            pStr++;
            // % 格式解析
            switch (*pStr)
            {
            case '%':
                my_send_char('%'); // %%，输出%
                ret_num++;
                pStr++;
                continue;
            case 'c':
                ArgIntVal = va_arg(pArgs, int); // %c，输出char
                my_send_char((char)ArgIntVal);
                ret_num++;
                pStr++;
                continue;
            case 'd':
                // 接收整型
                ArgIntVal = va_arg(pArgs, int);
                if (ArgIntVal < 0) // 如果为负数打印，负号
                {
                    ArgIntVal = -ArgIntVal; // 取相反数

                    my_send_char('-');
                    ret_num++;
                }
                val_seg = ArgIntVal; // 赋值给 val_seg处理数据
                // 计算ArgIntVal长度
                if (ArgIntVal)
                {
                    while (val_seg)
                    {
                        cnt++;
                        val_seg /= 10;
                    }
                }
                else
                    cnt = 1; // 数字0的长度为1

                ret_num += cnt; // 字符个数加上整数的长度

                // 将整数转为单个字符打印
                while (cnt)
                {
                    val_seg = ArgIntVal / m_pow_n(10, cnt - 1);
                    ArgIntVal %= m_pow_n(10, cnt - 1);
                    my_send_char((char)val_seg + '0');
                    cnt--;
                }
                pStr++;
                continue;
            case 'o':
                // 接收整型
                ArgIntVal = va_arg(pArgs, int);
                if (ArgIntVal < 0) // 如果为负数打印，负号
                {
                    ArgIntVal = -ArgIntVal; // 取相反数

                    my_send_char('-');
                    ret_num++;
                }
                val_seg = ArgIntVal; // 赋值给 val_seg处理数据
                // 计算ArgIntVal长度
                if (ArgIntVal)
                {
                    while (val_seg)
                    {
                        cnt++;
                        val_seg /= 8;
                    }
                }
                else
                    cnt = 1; // 数字0的长度为1

                ret_num += cnt; // 字符个数加上整数的长度

                // 将整数转为单个字符打印
                while (cnt)
                {
                    val_seg = ArgIntVal / m_pow_n(8, cnt - 1);
                    ArgIntVal %= m_pow_n(8, cnt - 1);
                    my_send_char((char)val_seg + '0');
                    cnt--;
                }
                pStr++;
                continue;
            case 'x':
                // 接收16进制
                ArgHexVal = va_arg(pArgs, unsigned long);
                val_seg = ArgHexVal;
                // 计算ArgIntVal长度
                if (ArgHexVal)
                {
                    while (val_seg)
                    {
                        cnt++;
                        val_seg /= 16;
                    }
                }
                else
                    cnt = 1; // 数字0的长度为1

                ret_num += cnt; // 字符个数加上整数的长度
                // 将整数转为单个字符打印
                while (cnt)
                {
                    val_seg = ArgHexVal / m_pow_n(16, cnt - 1);
                    ArgHexVal %= m_pow_n(16, cnt - 1);
                    if (val_seg <= 9)
                    {
                        my_send_char((char)val_seg + '0');
                    }
                    else
                    {
                        // my_send_char((char)val_seg - 10 + 'a'); //小写字母
                        my_send_char((char)val_seg - 10 + 'A');
                    }
                    cnt--;
                }
                pStr++;
                continue;
            case 'b':
                // 接收整型
                ArgIntVal = va_arg(pArgs, int);
                val_seg = ArgIntVal;
                // 计算ArgIntVal长度
                if (ArgIntVal)
                {
                    while (val_seg)
                    {
                        cnt++;
                        val_seg /= 2;
                    }
                }
                else
                    cnt = 1; // 数字0的长度为1

                ret_num += cnt; // 字符个数加上整数的长度
                // 将整数转为单个字符打印
                while (cnt)
                {
                    val_seg = ArgIntVal / m_pow_n(2, cnt - 1);
                    ArgIntVal %= m_pow_n(2, cnt - 1);
                    my_send_char((char)val_seg + '0');
                    cnt--;
                }
                pStr++;
                continue;
            case 's':
                // 接收字符
                ArgStrVal = va_arg(pArgs, char *);
                ret_num += (unsigned int)strlen(ArgStrVal);
                while (*ArgStrVal)
                {
                    my_send_char(*ArgStrVal);
                    ArgStrVal++;
                }

                pStr++;
                continue;

            case 'f':
                // 接收浮点型 保留6为小数，不采取四舍五入
                ArgFloVal = va_arg(pArgs, double);
                if (ArgFloVal < 0)
                {
                    my_send_char('-');
                    ArgFloVal = -ArgFloVal;
                }
                val_seg = (unsigned long)ArgFloVal; // 取整数部分
                val_temp = val_seg;                 // 临时保存整数部分数据
                ArgFloVal = ArgFloVal - val_seg;    // 得出余下的小数部分
                // 计算整数部分长度
                if (val_seg)
                {
                    while (val_seg)
                    {
                        cnt++;
                        val_seg /= 10;
                    }
                }
                else
                    cnt = 1;    // 数字0的长度为1
                ret_num += cnt; // 字符个数加上整数的长度
                // 将整数转为单个字符打印
                while (cnt)
                {
                    val_seg = val_temp / m_pow_n(10, cnt - 1);
                    val_temp %= m_pow_n(10, cnt - 1);
                    my_send_char((char)val_seg + '0');
                    cnt--;
                }
                // 打印小数点
                my_send_char('.');
                ret_num++;
                // 开始输出小数部分
                ArgFloVal *= 1000000;
                // printf("\r\n %f\r\n", ArgFloVal);
                cnt = 6;
                val_temp = (int)ArgFloVal; // 取整数部分
                while (cnt)
                {
                    val_seg = val_temp / m_pow_n(10, cnt - 1);
                    val_temp %= m_pow_n(10, cnt - 1);
                    my_send_char((char)val_seg + '0');
                    cnt--;
                }
                ret_num += 6;
                pStr++;
                continue;
            default: // % 匹配错误，暂输出空格
                my_send_char(' ');
                ret_num++;
                continue;
            }
            break;

        default:
            my_send_char(*pStr);
            ret_num++;
            break;
        }
        pStr++;
    }
    va_end(pArgs); // 结束取参数

    return ret_num;
}

// int myfunc_str_to_int(char *str,int n){
//     zf_assert(str != NULL);
//     uint8 sign = 0;                                                             // 标记符号 0-正数 1-负数
//     int32 temp = 0;   // 临时计算变量
////    int i = 0;
//    if(n == 0)
//    {
//        return 0;
//    }
//    if('-' == str[0])                                                         // 如果第一个字符是负号
//    {
//        sign = 1;                                                           // 标记负数
//    }
//
//    for (int j = 1;j < n;j ++){
//        temp = temp * 10 + ((uint8)(str[j]) - 0x30);                          // 计算数值
//    }
//    if(sign)
//    {
//        temp = -temp;
//    }
//    return temp;
//}

#endif
